# Deadlock
## 实验过程
1. 首先编写Deadlock的代码
2. 使用javac Deadlock.java进行编译
3. 然后创建Deadlock.sh文件，文件中将Deadlock执行100次，然后在terminal中 bash Deadlock.sh 执行文件
4. 观察结果

## 实验结果
![Deadlock reuslt](http://i.imgur.com/w6kAsT2.png)

**可以看到在第43次的时候出现了死锁的情况**
## 死锁的必要条件
1. 互斥：至少有一个资源必须处于非共享模式，即一次只能有一个进程使用，如果另一个进程申请该资源，那么申请进程必须等待到该资源被释放为止
- 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源。而该资源为其他进程所占有
- 非抢占：资源不能被抢占，即资源只能在进程完成任务之后自动释放
- 循环等待：有一组等待进程{P0,P1,....,Pn}, P0等待的资源为P1所占有，P1等待的资源为P2所占有，.....，Pn-1等待的资源为Pn所占优，Pn等待的资源为P0所占优<br>

**以上四个条件必须同时满足时才会出现死锁**

## 程序死锁分析
- 首先我们分析Deadlock.java文件中的代码，这份代码中首先定义了两个类，然后每个类都拥有两个成员函数，并规定这些成员函数都是可以同步执行的，这个同步执行为死锁奠定一个很关键的基础
- 然后Deadlock.java又定义了一个Deadlock类，这个类首先创建A类实例a，创建B类实例b，然后在这个类的构造函数中，创建一个线程，然后把这个线程插入调度队列，轮到这个线程执行时就是run函数，这个函数执行了b对象的methodB()函数，以a为参数
- 最关键的是，这个线程插入调度队列之后，过了20000个时间单位，执行a对象的moethodA()函数，以b为对象。如果此时刚好轮到上面定义的线程执行，这个线程要使用a对象，然而a对象也同时在执行，需要b对象，而b对象也在运行。这样就造成了一个死锁。